---
title: "11.盛水最多的容器"
description: "11.盛水最多的容器"
keywords: "11.盛水最多的容器"

date: 2023-11-06T21:20:49+08:00
lastmod: 2023-11-06T21:20:49+08:00

categories:
  - leetcode
tags:
  - 每日一题


# 原文作者
author: zzzi
# 开启数学公式渲染，可选值： mathjax, katex
# Support Math Formulas render, options: mathjax, katex
math: mathjax

# 开启文章置顶，数字越小越靠前
# Sticky post set-top in home page and the smaller nubmer will more forward.
#weight: 1
# 关闭文章目录功能
# Disable table of content
#toc: false


# 原文链接
# Post's origin link URL
#link:
# 图片链接，用在open graph和twitter卡片上
# Image source link that will use in open graph and twitter card
#imgs:
# 在首页展开内容
# Expand content on the home page
#expand: true
# 外部链接地址，访问时直接跳转
# It's means that will redirecting to external links
#extlink:
# 在当前页面关闭评论功能
# Disabled comment plugins in this post
#comment:
#  enable: false

# 绝对访问路径
# Absolute link for visit
#url: "11.盛水最多的容器.html"


# 开启各种图渲染，如流程图、时序图、类图等
# Enable chart render, such as: flow, sequence, classes etc
#mermaid: true
---

>🥕11.盛水最多的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

<!--more-->

## 思路

### 示例

**示例 1：**

![img](https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202311062122018.jpeg)

```java
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```java
输入：height = [1,1]
输出：1
```

### 基本思想

为了找出最大的容器，肯定容器的边界越大越好，所以容器的边界需要从两边开始向中间收缩，收缩的过程中记录下最大的容量，收缩到中点之后，就得到了最大的容量

需要注意的细节就是，每次收缩时，收缩尽可能小的边，并且更新时，需要保留大的容量

### 执行流程

1. 从两边向中间收缩，遇到了中点收缩完毕
2. 收缩的过程中，每次搜索较小的一边，也就是缩小短板，才能有出现更高边界的情况出现
3. 收缩的过程中记录最大的容量

## 代码

根据以上分析，得出以下代码：

```java
class Solution {
    public int maxArea(int[] height) {
        int res=0;
        int start=0,end=height.length-1;
        while(start<end){
            int high=Math.min(height[start],height[end]);
            int weight=end-start;
            res=Math.max(res,high*weight);
            //尽可能的收缩小的边
            if(height[start]<height[end])
                ++start;
            else
                --end;
        }
        return res;
    }
}
```

## 总结

为了得到最大容量，尽可能的保留最宽的范围，也就是需要**从两边向中间收缩**，并且收缩的过程中尽可能**去掉短板**，才能有希望找到**长板**，从而提高容量
