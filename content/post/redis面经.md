---
title: "Redis面经"
description: "redis面经"
keywords: "redis面经"

date: 2024-03-04T12:57:25+08:00
lastmod: 2024-03-04T12:57:25+08:00

categories:
  - 面试
tags:
  - redis
  - 面经

# 原文作者
# Post's origin author name
author: zzzi
# 开启数学公式渲染，可选值： mathjax, katex
# Support Math Formulas render, options: mathjax, katex
math: mathjax
# 原文链接
# Post's origin link URL
#link:
# 图片链接，用在open graph和twitter卡片上
# Image source link that will use in open graph and twitter card
#imgs:
# 在首页展开内容
# Expand content on the home page
#expand: true
# 外部链接地址，访问时直接跳转
# It's means that will redirecting to external links
#extlink:
# 在当前页面关闭评论功能
# Disabled comment plugins in this post
#comment:
#  enable: false
# 关闭文章目录功能
# Disable table of content
toc: false
# 绝对访问路径
# Absolute link for visit
#url: "redis面经.html"
# 开启文章置顶，数字越小越靠前
# Sticky post set-top in home page and the smaller nubmer will more forward.
#weight: 1

# 开启各种图渲染，如流程图、时序图、类图等
# Enable chart render, such as: flow, sequence, classes etc
#mermaid: true
---

> 🛅 redis面经

本文主要介绍一些redis的常见面试题，文章长期更新，面试答案参小林coding的[图解系列](https://xiaolincoding.com/)，第一章面试篇就是整体的面试题，后面几章是对面试篇中一些重点问题的补充

<!--more-->

#### redis定义

redis是一种基于内存的数据库，数据读写都在内存中完成，因此读写速度很快，常用语缓存，消息队列，分布式锁等场景

#### redis和Memcached的区别

1. 都是基于内存的数据库，常用来作缓存
2. 都有过期策略，性能都很高

> 区别

1. redis支持的数据类型更丰富，Memcached只支持key-value
2. redis支持数据持久化，可以将内存中的数据同步到磁盘中
3. redis原生就支持集群，Memcached只能通过客户端来实现集群
4. redis功能更强大

#### 为什么使用redis做mysql的缓存

1. redis具备高性能：数据经过redis缓存在内存中，访问速度会大大加快
2. redis具备高并发：针对请求量来说，redis每秒能够处理的请求量是mysql的十倍以上

所以我们使用redis作缓存，这样mysql中的一部分数据缓存在了redis中，可以减小数据访问的事件，提高系统的运行效率

#### redis的数据类型

1. String：可存储字符串，整数，浮点数，<u>常用来缓存对象，技术，和一些共享信息</u>
2. Hash：键值对形式的散列表，<u>常用来缓存对象</u>
3. List：链表，每个节点都是一个字符串，<u>常用来做消息队列，要自己实现全局唯一消息id</u>
4. Set：字符串的无序集合：<u>常用来做集合之间的聚合计算（交并差）</u>
5. Zset：字符串的不允许重复的集合，每个元素带一个分数，<u>常用来进行排序</u>

> 随着版本更新，后面又新增了一些数据类型

1. BitMap：二进制状态的场景，签到，判断是否登录
2. HyperLoglog：数据统计，比如网页访问计数
3. GEO：存储地理位置信息
4. Stream：消息队列，相比于List实现的消息队列，Stream可以自动生成全局唯一消息id

#### redis中数据类型的实现原理

<img src="https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f.png" alt="img" style="zoom: 43%;" />

1. String：SDS(简单动态字符串)，不仅可以保存文本数据，还可以保存二进制数据，内部提供很多方便且安全的api(获取字符串长度，拼接字符串)
   1. List：当元素个数小于512个且每个元素值都小于64字节时使用压缩列表，否则使用双向链表，**新版本**中使用quickList代替压缩列表（节点是压缩列表，并将链表分段，段间使用双向链表）
   2. Hash：当元素个数小于512个且每个元素值都小于64字节时使用压缩列表，否则使用哈希表，新版本中使用listpack（紧凑列表）**代替**压缩列表
   3. Set：元素个数小于512使用整数集合（不重复且有序），否则使用哈希表
   4. ZSet：元素个数小于128且元素大小小于64字节使用压缩列表，否则使用跳表（给有序链表的节点加上索引，使得有序链表可以随机访问），新版本使用listpack代替压缩列表

#### redis是单线程吗

> 不是

在外部来看，客户端发送请求到请求解析并执行最后返回结果的这一个**过程是由单线程**处理的，但是实际上内部还有**后台线程**，用来关闭文件，异步删除，持久化 AOF日志等操作

一般比较耗时的任务都会交给这些后台线程，这样就不会出现主线程阻塞的问题

#### 为什么redis单线程这么快

1. 操作都在内存中，限制性能的其实不是cpu而是存储设备和网络的读写性能
2. 单线程可以避免多线程之间的竞争导致的进程切换所消耗的时间
3. 使用I/O多路复用处理大量的客户端请求，将这些请求都交给redis线程快速处理

#### redis之后为什么采用多线程

这是因为网络i/o存在瓶颈，引入多线程只是去处理网络I/O的处理速度，执行客户端命令时还是使用单线程（主线程）

如果想要执行客户端命令的时候使用多线程，可以开启一个开关进行**配置**

#### redis中的线程有哪些

> 除开主线程，还有**六个额外**的线程

1. 主线程：执行客户端的命令
2. 异步关闭文件的线程
3. 持久化AOF文件的线程
4. 释放内存的线程
5. **三个**处理网络I/O的线程

#### redis如何利用多个cpu或者多核cpu

> cpu并不是限制redis性能的原因，真正原因是因为存储设备和网络
>
> 如果想要使用多个cpu或者多核cpu，可以启动多个redis节点或者使用分片集群（数据分成多份，每一个节点持有一份）

#### redis持久化

> redis持久化有两种方式

1. AOF日志：**写后日志**，先写数据，再写日志，日志中记录的是redis命令，<u>mysql是写前日志</u>，redis使用写后日志的目的是为了提高性能，但是可能丢失数据

   出现日志时，**先**记录在aof的缓冲区，**后续**有三种将缓冲区的日志写入aof文件的策略：

   - Always：每次写日志都同步到aof文件中

   - Everysec：每秒同步一次

   - No：由os控制日志的持久化

     <img src="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a-20230309232253633.png" alt="img" style="zoom:33%;" />

2. RDB快照：给内存拍照，将此时刻的文件记录到磁盘中持久化（**二进制方式**），可以手动也可以自动。由于AOF文件的记录频率比RDB快照高，所以redis会默认先使用AOF文件来恢复

3. 混合方式：AOF+RDB快照，恢复较快，记录也较快，结合二者优点，父子进程共享的数据以RDB方式持久化，在持久化期间执行的命令由AOF方式持久化

#### redis持久化方式的优缺点

1. AOF记录命令，记录较快，恢复较慢，需要执行命令，由于其记录较快，所以一旦发生故障，丢失的数据较少
2. RDB记录数据，恢复较快，但是记录较慢，由于其记录较慢，所以一旦发生故障，丢失的数据就会较多，频繁地快照又会影响性能

#### AOF重写

> 为了给AOF文件瘦身

在redis的运行过程中，产生的日志越来越多，此时AOF文件就会越来越大，于是redis会将这个AOF文件进行重写，**去掉冗余文件**，这个操作是由后台线程完成的

当前数据被更新，之前记录的redis操作命令就是冗余的，也就是历史命令冗余

触发方式可以手动也可以自动，什么时候自动可以通过参数配置

#### AOF重写过程中发生了数据修改

> 设置一个AOF重写缓冲区，重写完成之后再将重写过程中发生的修改操作追加到新的AOF文件中

当AOF重写过程中发生了数据修改，**主线程**会做下面几步：

1. 执行修改命令
2. 将命令保存到AOF缓冲区等待持久化
3. 将命令保存到AOF重写缓冲区中（<u>只有发生AOF重写时才有这一步</u>）

当子进程重写工作完成之后，主进程会将重写缓冲区中的命令追加到新的AOF文件中（保存了最新的操作命令），并改名覆盖旧的AOF文件，此时就完成了AOF重写，并且数据保持一致

#### redis集群的几种方式

1. 主从复制：多个节点之间数据一致，读写分离
2. 哨兵：可以监控主从节点，并且发生故障时可以进行主从节点故障转移
3. 分片集群：数据切分，每个节点保存一部分，数据和节点之间的映射关系使用哈希槽表示，从而可以快速定位数据所在节点，每个节点保存了多个哈希槽，从而根据哈希槽就可以知道数据所在位置

#### redis集群脑裂是什么

> 主从节点之间连接断开，但是主节点A和客户端连接没有断开
>
> 此时客户端还向主节点A发送请求，主节点A中的数据更新，哨兵发现主从节点连接断开，选举新的主节点B，此时有两个主节点：**脑裂**
>
> 哨兵将将主节点A降级为从节点A，从节点A同步主节点B的数据，会覆盖自己的数据，而自己的数据是最新的数据，覆盖之后**数据丢失**

#### 脑裂解决方法

主节点发现从节点下线或者通信超时的数量超过阈值后就禁止写操作并向客户端报错

> 这个下线数量和通信超时时间可以设置

#### redis过期删除策略

> 惰性删除+定期删除

当key设置了过期时间，将key和过期时间保存到字典中，每次查询判断key是否在字典中：

1. 在字典中，判断过期时间与系统时间的关系从而判断是否要删除
2. 不在字典中，说明不过期

- 惰性删除：不主动删除key，只有判断当前key过期才删除

- 定期删除：每一段时间检查一部分key是否过期，过期就删除，当这部分key过期的数量太多，那么就继续检查下一部分

#### redis持久化时，过期键处理方式

1. RDB文件生成阶段：生成时对key进行过期检查，所以RDB生成的文件中没有过期的key
2. RDB文件加载阶段：
   - RDB文件加载到主库，过期的key不加载
   - RDB文件加载到从库，过期的key也加载
3. AOF文件写入阶段：没删除的过期keyAOF文件保留，删除的过期keyAOF文件中追加一个DEL命令显式标记
4. AOF重写阶段：已过期的key相当于冗余，不保存到新的AOF文件中

#### redis主从模式总，过期键处理方式

1. 主库：key到期会在AOF文件中使用一个DEL命令标记，从库同步数据时参会删除
2. 从库：除了同步时删除过期的key，平时不管

#### redis内存满了之后的内存淘汰机制

1. 不数据淘汰：内存满了直接报错
2. 进行数据淘汰（分为局部淘汰和全局淘汰）：
   - 在过期数据中淘汰（局部）
     - 随机淘汰
     - 淘汰最早过期的
     - 淘汰所有
     - 淘汰最少使用的
   - 在所有数据中淘汰（全局）
     - 随机淘汰
     - 淘汰最久未使用的
     - 淘汰使用最少的

#### redis中的LRU（最近最少使用）：时间

> 传统的LRU是使用链表组织数据，最新访问的数据在链表头，淘汰时优先淘汰链表尾

redis中给数据的结构中添加一个**最后一次访问时间**字段，然后淘汰时随机选5个值，淘汰最久没有使用的那个数据

如果某一次读取大量数据，这些数据的最后一次访问时间就会更新，后续不再使用的话，会在内存中保留很长一段时间：**缓存污染**

#### redis中的LFU（最近最不常用）：次数

> 相比于LRU中根据时间判断，LFU根据访问次数判断，这根据程序的时间局部性原理

redis给数据的结构中添加一个**最后一次访问时间和访问频次（初始化为5）**的字段

当数据被访问时，先按照访问时间间隔来减小访问频次，减小之后再增加，访问频次越大的数据增加的幅度越小

删除时访问频次低的优先删除，访问频次相同时，最后一次访问时间久的优先删除

#### redis缓存雪崩定义和解决办法

> 当缓存中大量时间在同一时间失效，此时客户端请求就无法在redis中处理，进而全部转到数据库中，请求量过大可能造成数据库宕机，从而出现**一系列连锁反应**
>
> 这种针对大量数据缓存失效造成的一系列反应称为缓存雪崩

1. 不让大量数据在同一时间失效：将数据的过期时间打散，使数据不集中过期
2. 设置缓存不过期：让后台定期更新缓存，使得缓存和数据库中的数据保持一致，从而避免因为缓存失效导致缓存雪崩

#### redis缓存击穿定义和解决办法

> 当某些数据被频繁访问，这种数据称为热点数据
>
> 热点数据失效就会导致该热点数据的很多请求最终到达数据库，请求量过大就可能造成数据库故障
>
> 这种针对部分数据失效造成的现象称为缓存击穿

1. 设置互斥锁：保证同一时间只有一个线程请求缓存
2. 热点数据设置为不过期：后台异步更新热点数据，从而不会出现请求访问热点数据过期的问题发生

#### redis缓存穿透定义和解决办法

> 用户访问的数据**既不在**缓存中，**也不在**数据库中，大量的这种请求到达数据库，这种现象称为缓存穿透，**出现原因**一般有几种：
>
> 1. 业务误操作：缓存和数据库中的数据被误删除
> 2. 黑客攻击：黑客故意删除缓存和数据库中的数据，或者故意访问缓存和数据库中都不存在的数据

1. 非法请求限制：当存在恶意请求时，我们直接拦截
2. 设置空值或者默认值：缓存和数据库中都没有想要的数据时，此时设置一个空值或者默认值给客户端
3. 设置布隆过滤器：快速判断数据库中是否存在目标数据，这样缓存中的数据失效后，根据布隆过滤器也得到数据库中没有，请求就直接不会到达数据库从而引发缓存穿透

**布隆过滤器**：通过散列函数将元素进行映射，并且将对应位置为1，判断元素存在时就根据散列函数映射到对应位置看这个位置是否为1即可

#### redis如何缓存热点数据

> 思路：通过数据访问时间排序，留下经常访问的数据

1. LRU算法：根据数据的访问时间排序，定期删除访问时间太久远的数据，并且更新一部分新的数据到缓存中
2. LFU算法：根据数据的访问时间更新数据的访问频次，先衰减再更新，按照更新后的访问频次决定数据的去留

#### 缓存更新策略

1. 旁路缓存：应用程序**直接与数据库和缓存**打交道（适合读多写少的情况，此时才不会造成缓存的频繁更新，降低缓存命中率）
   - 写策略：出现写数据的请求时，先写入数据库，然后删除缓存
   - 读策略：缓存中命中直接返回，没命中先查数据库并存入缓存，最后返回给用户
2. Read/Write Through（读穿 / 写穿）策略：应用**只与缓存**交互，数据同步由缓存自己控制
   - Read Through：先读缓存，存在就返回，不存在由缓存从数据库中读取并写入缓存，最后返回给客户端
   - Write Through：如果缓存中有数据则更新，之后由缓存更新数据库，缓存中没有则直接更新数据库
3. Write Back（写回）策略：只更新缓存并将其设置为**脏数据**，后期**异步**更新数据库
