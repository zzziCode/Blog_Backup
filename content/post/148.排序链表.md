---
title: "148.排序链表"
description: "148.排序链表"
keywords: "148.排序链表"

date: 2023-09-24T21:33:18+08:00
lastmod: 2023-09-24T21:33:18+08:00

categories:
  - leetcode
tags:
  - 每日一题


# 原文作者
author: zzzi
# 开启数学公式渲染，可选值： mathjax, katex
# Support Math Formulas render, options: mathjax, katex
math: mathjax

# 开启文章置顶，数字越小越靠前
# Sticky post set-top in home page and the smaller nubmer will more forward.
#weight: 1
# 关闭文章目录功能
# Disable table of content
#toc: false


# 原文链接
# Post's origin link URL
#link:
# 图片链接，用在open graph和twitter卡片上
# Image source link that will use in open graph and twitter card
#imgs:
# 在首页展开内容
# Expand content on the home page
#expand: true
# 外部链接地址，访问时直接跳转
# It's means that will redirecting to external links
#extlink:
# 在当前页面关闭评论功能
# Disabled comment plugins in this post
#comment:
#  enable: false

# 绝对访问路径
# Absolute link for visit
#url: "148.排序链表.html"


# 开启各种图渲染，如流程图、时序图、类图等
# Enable chart render, such as: flow, sequence, classes etc
#mermaid: true
---

>🧭 148.排序链表

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

<!--more-->

## 思路

### 基本思想

为了给链表排序，最简单的办法就是将链表转化成数组，之后应用容器自带的排序规则排序，之后再转回链表，就是一个暴力模拟的过程，代码如下：

```c
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int> temp;
        while(head!=nullptr){
            temp.push_back(head->val);
            head=head->next;
        }
        sort(temp.begin(),temp.end());
        ListNode* dummyHead=new ListNode(0);
        ListNode* res=dummyHead;
        for(auto val:temp){
            ListNode* node=new ListNode(val);
            res->next=node;
            res=res->next;
        }
        res->next=nullptr;
        return dummyHead->next;
    }
};
```

但是这种方法的时间复杂度太高。于是想到了拆分在合并的思想，现将链表拆分成一个一个的单节点，之后将单节点两两合并，这用到了二分法和归并的思想，先使用二分法将链表拆分成一半一半的，一直递归的拆分，当拆分成单节点之后，开始合并

合并的时候是在回溯的时候，每次取左右两个链表依次合并形成更大的链表，之后返回上一层时，形成的链表是一个有序的，这样一层一层向上，最终得到一个完整的排序链表

<img src="https://pic.leetcode-cn.com/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png" alt="Picture2.png" style="zoom:50%;" />

### 执行流程

1. 递归将当前链表划分成两半（使用快慢指针的思想划分）
2. 当节点是一个单节点时返回
3. 整个链表的节点都变成单节点之后开始回溯
4. 回溯的过程中进行链表的有序合并
5. 形成更大的链表之后向上层返回

## 代码

根据以上分析，得出以下代码：

```c
class Solution {
public:
    //暴力法能过
    //递归过不了？？？
    ListNode* sortList(ListNode* head) {
        if(head==nullptr||head->next==nullptr)
            return head;
        ListNode* fast=head->next;
        ListNode* slow=head;
        //将当前链表分割成两半
        while(fast!=nullptr&&fast->next!=nullptr){
            fast=fast->next;
            slow=slow->next;
        }
        ListNode* temp=slow->next;
        //链表等分成两部分
        slow->next=nullptr;
        ListNode* left=sortList(head);
        ListNode* right=sortList(temp);
        ListNode* dummyHead=new ListNode(0);
        ListNode* node=dummyHead;
        //开始合并时说明链表中的额节点被分割成了单个节点
        //每个节点的next都指向了nullptr
        //所以不需要考虑当前链表的尾部是否为空
        //找小的现将当前两个节点合并
        while(left!=nullptr&&right!=nullptr){
            if(left->val<right->val){
                node->next=left;
                node=node->next;
                left=left->next;
            }else{
                node->next=right;
                node=node->next;
                right=right->next;
            }
        }
        node->next=left==nullptr?right:left;
        return dummyHead->next;

    }
};
```

## 总结

利用了归并排序的思想，在递归的过程中对链表拆分，在回溯的过程中对链表合并，最终经过递归回溯，形成了完整的链表
