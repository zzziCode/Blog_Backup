---
title: "Mysql面经"
description: "mysql面经"
keywords: "mysql面经"

date: 2024-02-28T09:56:32+08:00
lastmod: 2024-02-28T09:56:32+08:00

categories:
  - 面试
tags:
  - mysql
  - 面经

# 原文作者
# Post's origin author name
author: zzzi
# 开启数学公式渲染，可选值： mathjax, katex
# Support Math Formulas render, options: mathjax, katex
math: mathjax
# 原文链接
# Post's origin link URL
#link:
# 图片链接，用在open graph和twitter卡片上
# Image source link that will use in open graph and twitter card
#imgs:
# 在首页展开内容
# Expand content on the home page
#expand: true
# 外部链接地址，访问时直接跳转
# It's means that will redirecting to external links
#extlink:
# 在当前页面关闭评论功能
# Disabled comment plugins in this post
#comment:
#  enable: false
# 关闭文章目录功能
# Disable table of content
toc: false
# 绝对访问路径
# Absolute link for visit
#url: "mysql面经.html"
# 开启文章置顶，数字越小越靠前
# Sticky post set-top in home page and the smaller nubmer will more forward.
#weight: 1

# 开启各种图渲染，如流程图、时序图、类图等
# Enable chart render, such as: flow, sequence, classes etc
#mermaid: true
---

> 📈 mysql面经

本文中主要介绍一些mysql的面试笔记，文章持续更新

<!--more-->

#### sql语句执行的流程

<img src="https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202402280956296.png" alt="查询语句执行流程" style="zoom: 50%;" />

1. 连接器：建立连接（TCP），之后所有的查询操作都会先判断当前用户的权限，长时间（28800）不用的连接会被释放，并且连接数不能超过151

2. 查询缓存：select会查询缓存，看是否曾经执行过，对于更新频繁的表，缓存基本无用

3. 解析SQL：主要是词法分析和语法分析，分析成功就会得到一个SQL**语法树**

4. 执行SQL：

   - 预处理SQL：替换*，判断字段和表是否存在

   - 优化SQL：使得SQL执行的效率变高，例如存在主键索引（id）和普通索引（其余字段加索引）时，会判断使用哪个索引的效率更高

   - 执行SQL：与存储引擎交互查询数据

     - 主键索引查询：直接利用主键索引查询

     - 全表扫描：全表扫描一遍

     - 索引下推：将索引的判断工作交给存储引擎端，减少回表操作，这里涉及到一个联合索引的操作，由于存在最左匹配原则，当出现范围查询时，联合索引的范围查询可以使用索引，但是剩下的字段无法使用索引（因为局部无序），所以剩下的字段需要进行回表，将存储引擎查询到的数据在服务端再进行筛选，索引下推可以使得这个筛选工作在存储引擎端完成，从而减小回表操作，提高效率，**举例**：

       > `select * from t_table where a > 1 and b = 2`，联合索引（a, b）
       >
       > 此时联合索引会先按照a排序，然后存储引擎找到所有a>1的数据的id，在这些数据里，b没有进行排序，所以联合索引失效，这些数据需要进行回表进一步筛选，索引下推可以将筛选的工作交给存储引擎端，减小数据传输的事件

#### mysql一行记录如何存储

> 数据存储由行，页，区，段组成，每一行数据分为额外信息和真实数据，额外信息包含变长字段的长度以及NULL值列表（二者可能不存在），真实数据包含三个隐藏字段（隐藏自增id，事务id，上一个版本指针）以及真实值

一旦建立数据库中的一张表，那么就会在`/var/lib/mysql/` 中建立一个对应的数据库，内部新增三个文件：

```mysql
db.opt  
表名.frm  
表名.ibd
```

1. db.opt：存储数据库的默认字符集和校验规则
2. 表名.frm ：存储表结构信息
3. 表名.ibd：存储表中的数据，默认存储在这个**独占表空间文件**（.ibd文件）中，但是一个参数可以控制数据存放在**共享表空间文件**（.ibdata1文件）中

mysql中数据存储按照**段，区，页，行**来组织，双向链表中连续的页在物理上也连续，一个区有1mb，区内有64个连续的页，而多个区组成一个

<img src="https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202402281055554.png" alt="img" style="zoom:43%;" />

对于一行数据，现在默认采用`dynamic`，这是从`compact`改进得到的

<img src="https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202402281055841.png" alt="img" style="zoom:50%;" />

1. 变长字段就存储了行记录中变长字段的具体长度，**逆序**存放（读指针指向额外信息和真实数据之间，向左读可以读到额外信息，向右读可以读到真实数据）

2. NULL值使用一个**二进制位**记录，也是逆序存放，一行记录的某一列为NULL，二进制位的对应位置就为1，字段不足八位高位补0

> 上面两位都不是必须的，表结构中有变长或者允许为空时才存在这两个信息

3. 记录头信息中存放当前行记录是否被删除，下一条记录的位置等信息
4. 真实数据存在三个隐藏列：
   - row_id：数据没有主键以及非空的唯一字段时增加这个隐藏的自增id
   - trx_id：事务id，标记由哪个事务生成
   - roll_pointer：上一个版本的指针

#### mysql中数据页的格式

> b+树中非叶子节点存储的是id（页中最小行记录的id）和页号，一个非叶子节点存储多个这样的记录，叶子结点就正常存储行数据，用双链表组织：
>
> <img src="https://cdn.xiaolincoding.com//mysql/other/6374409c6c404d446855dc6a694b6d26.png" alt="图片" style="zoom:50%;" />

数据页（默认16kb）中存放的是一行一行的数据，是最小的查询单位，多行数据之间进行分组并建立页目录，页目录中的一个槽指向一个分组中的最大记录，相当于数据页中的行数据还进行了分组，查询时是二分+顺序的方式

数据页之间的组织方式是双向链表，数据页内部的行数据组织方式是按主键顺序单向链表

InnoDB的行格式

1. redundant
2. compact（紧凑的行格式）
3. dynamic
4. compressed

#### 聚簇索引和二级索引的区别

1. 聚簇索引：通常是主键索引，或者是非空的唯一字段索引，极端情况为隐式的自增id索引，聚簇索引中叶子结点存放的是**数据**

2. 二级索引：非主键字段的索引，叶子结点存放的是**主键id**，所以查询到id之后还会进一步利用聚簇索引查询到真实的数据，这一操作叫做回表，如果此时刚好需要的就是主键，此时这个过程就叫做**覆盖索引**

   > 相当于给哪个非主键字段加索引，就会形成一个b+树，叶子结点保存的是主键id，而不是数据，需要进行**回表**

#### 什么叫覆盖索引

> 使用二级索引一次就能查询得到结果的过程

当非主键字段存在索引时，在这个字段上进行查找会最终找到b+树中的一个叶子结点得到一个主键值，正常情况下需要回表得到主键值对应的真实数据，但是如果我们**正好需要的就是这个主键值**，那么就**不需要回表**，此时成为覆盖索引

#### varchar(n)中的n最大取值是多少

保证真实数据+变长字段所需字节+NULL值列表<=65535字节

#### 行溢出怎么处理

一页大小为16kb，也就是16384字节，而一行数据最大为65535字节，如果一页存储不了一行数据，那么多余的数据就会存储在**溢出页**中，存放真实数据的地址中会分配一部分指向溢出页的地址

<img src="https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202402281056468.png" alt="img" style="zoom:33%;" />

#### mysql的存储引擎

1. innodb（默认）
2. myisam
3. memory

#### 索引定义及分类

索引就是数据的目录，可以加快查找数据的速度

![image-20240229093806087](C:/Users/zzzi/AppData/Roaming/Typora/typora-user-images/image-20240229093806087.png)

> 给谁建立索引，谁就是b+树节点中的key值

#### 联合索引的最左匹配

由于存在最左匹配，所以要先匹配左边的字段，例如给（a,b,c）建立索引，此时就要先匹配a，因为内部按照a进行排序，其余两个字段是全局无序的（只有a相同才会对b排序，只有a和b相同才会对c排序）

如果不按照最左匹配，联合索引就会失效，存在只有部分字段使用到了联合索引的情况，select * from t_table where **a > 1** and b = 2和select * from t_table where **a >= 1** and b = 2存在区别，后一句中的a可以等于1，于是内部的b可以使用到联合索引，前一句不行

> 联合索引是否失效取决于最左匹配的字段**是否可以相等**

#### 联合索引的区分度

建立联合索引时，区分度大的字段要排在左边

![区分度计算公式](https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202402291004066.png)

不同值越多，区分度越大

#### b+树相对于b树，二叉树，哈希的优势

1. b树每个节点都存储值，b+树只有叶子结点存储数据，单个节点的数据量更小，一次i/o读取到的节点更多
2. 二叉树孩子节点只能有两个，b+树可以有多个，树高更小，i/o次数就更少
3. hash只适合做等值查询，不适合做范围查询

#### 索引优化

1. 前缀索引优化：只将一个字段的前几个值建立索引，减小索引字段的大小
2. 覆盖索引优化：将要查询的字段建立一个联合索引，这样就不用回表，使用主键再次查询
3. 主键索引递增：由于b+树中的数据按照顺序存放，主键递增可以使得新增数据是追加操作，不用移动数据
4. 索引设置非空：存在NULL导致索引建立更加复杂，且NULL值还会占用行记录的空间（NULL值列表占用空间）

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png" alt="img" style="zoom:50%;" />

#### 索引失效

1. 对索引字段使用**左**或者**左**右模糊匹配（`like %xx`或者`like %xx%`）：只要左边模糊了，那么索引就会失效，因为索引匹配按照**前缀**，这里左边模糊了，前缀无法匹配，自然失效

   > 这里有特殊情况（**没问到就不说**），当表中的字段没有非索引字段时，索引就不会失效，因为此时二级索引形成的b+树就可以直接得到结果（覆盖索引），比全表扫描更快，这取决于**优化器**的选择

2. 对索引字段使用**函数**：因为索引字段建立索引使用的是原值，而不是使用函数后的值，相当于没有这种索引（`select * from t_user where length(name)=6`）

   > mysql8之后增加了函数索引，此时才可以对索引字段使用函数

3. 对索引字段进行**表达式计算**：表达式计算之后的值没有建立索引，所以索引失效（`select * from t_user where id + 1 = 10`）

4. 索引字段发生**隐式类型转换**：mysql会自动将字符串转换成数字，所以下面的phone都转换成了数字，而没有这种索引，‘1’转换成数字，存在这种索引

   > 主要看字符串转成数字还是数字转换成字符串

   - select * from t_user where phone = 1300000001**失效**
   - select * from t_user where id = '1'**不失效**

5. 联合索引**非最左匹配**：先按照左边的排序，左边的相同才按照右边的排序，所以使用时没有先匹配左边的，联合索引就会失效（对a,b,c建立索引但是匹配b或者c就会索引失效，但是匹配a就不会）

6. 联合索引**索引截断**：对a,b,c建立索引，对于a进行范围查询且**没有等于**，后面的b就不会进行联合索引查询，因为只有a相等才会对b进行联合索引查询

> 在联合索引的情况下，按照索引第一列排序，第一列数据相同时才会按照第二列排序

7. where子句中的or：or的前后只要有一个不是索引，就会进行全表扫描，因为不是索引的字段会进行全表扫描，再进行索引反而浪费
8. 非空查询：这种情况下，全表扫描反而更方便
9. 扫描的行记录过多：此时优化器可能选择全表扫描

#### mysql为什么使用b+树做索引 

1. 索引存储在磁盘中（**速度**慢），要尽可能减小磁盘读写次数
2. b+树做索引使得查找和新增索引时都比较快（**效率**高），并且层高较低
3. 只有叶子结点存放真实数据，同样的大小，b+树**存储的节点更多**，一次读写的索引更多
4. b+树中的叶子结点使用双链表连接，**范围查询**很方便

#### mysql单表不要超过2000W

> 根据非叶子节点能存储的其他页（当前页最小数据的id+页号）的数量以及叶子节点能存储的数据行数决定单表最大存储数据量

因为b+树的节点是一个页，存储的数据是有限的，其大小为16k，加上文件头，页头等附加信息，大概还剩15k用于存储数据，非叶子节点大概能存储1000多个其余页的信息（也就是有1000叉），叶子结点大概能存储15条记录，再加上b+树最多3层（为了减小i/o），故真正存储数据的**叶子结点**数为：

`n叉^(层数-1)=1000^2*15=1500W`

> 原理就是计算出n叉b+树的叶子结点个数，然后看每个叶子结点能存储多少条数据

#### 关于count(*)和count(1)

<img src="https://cdn.xiaolincoding.com//mysql/other/af711033aa3423330d3a4bc6baeb9532.png" alt="图片" style="zoom:50%;" />

> count函数执行时，server层会维护一个count变量记录结果

1. **count(主键字段)**的执行过程

   1. 只有主键索引（聚簇索引）就利用主键索引查询，判断其id是否为空，从而更新count

   2. 有二级索引就先用二级索引，判断其id是否为空从而更新count

      > 因为二级索引叶子结点存储的是主键id，而聚簇索引叶子结点存储真实数据，相同数量的索引，二级索引占用空间更小，i/o成本更小

2. count(1)的执行过程

   1. 只有主键索引（聚簇索引）就利用主键索引查询，直接更新count

   2. 有二级索引就先用二级索引，直接更新count

      > 相比于count(主键字段),count(1)不用判断id是否为空，**效率更高**

3. count(*)执行过程

   > 将*转换为0，剩下过程与count(1)一样

4. count(字段)的执行过程

   > 此时这个字段没有索引，只能全表扫描，效率最差

#### 优化count(*)

1. 不直接执行count(*)，而是使用效率更高的`explain`得到近似值

   > 适用于不需要精确结果的统计

2. 将count数目单独维护到额外的一张表中，增删都更新这张表

#### 事务的特性（ACID）

1. 原子性：事务就是最小的执行单位，事务中的所有操作要么全部完成，要么全部不完成
2. 一致性：事务执行前后，数据保持一致，例如转账的总金额保持一致，出多少入多少
3. 隔离性：事务之间的执行是隔离的
4. 持久性：事务的操作被提交之后，影响是永久的

<img src="https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202312111423205.png" alt="AID- style="zoom: 33%;" >C" />

#### 事务的传播行为

> 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播

|            传播行为            |                             说明                             |
| :----------------------------: | :----------------------------------------------------------: |
|   **`PROPAGATION_REQUIRED`**   | 当前不存在事务，那么就新建一个事务，否则就加入当前的事务，这是默认使用的事务传播行为。如果方法 A（PROPAGATION_REQUIRED）调用了方法 B（PROPAGATION_REQUIRED），方法 B 将加入到方法 A 的事务中。如果方法 B 抛出异常，则方法 A 和 B 都会回滚。 |
| **`PROPAGATION_REQUIRES_NEW`** | 当前存在事务，会将当前事务**挂起**，然后执行自己的事务，相当于事务之间互不影响，挂起当前事务的操作是与**`PROPAGATION_NESTED`**最核心的区别 |
|    **`PROPAGATION_NESTED`**    | 当前存在事务，会在当前事务内部重新创建一个事务，二者相互不影响，并且当前事务并不会被挂起，如果当前不存在事务，那么**`PROPAGATION_NESTED`**与**`PROPAGATION_REQUIRED`**等价 |
|    `PROPAGATION_MANDATORY`     |         当前存在事务加入当前事务，不存在事务抛出异常         |
|      `PROPAGATION_NEVER`       |            以非事务方式运行，当前存在事务抛出异常            |

> 事务的传播行为指的是事务在执行过程中**遇到其他类型的事务怎么处理**，分为加入，新建，嵌套，报错等处理方式

#### 事务的数据一致性问题

在介绍事务的隔离级别之前，会介绍并发事务中可能遇到的一些数据一致性问题：

1. **脏读**（读未提交）：指的是一个事务读取了另外一个事务未提交的数据。一个事务由于一些情况修改了数据但是最终并没有提交，而这个没有被提交的事务被其他事务读取到就会出现脏读
2. **不可重复读**（数据值不一样）：指的是对于**同一行**数据来说，由于没有针对事务的并发操作进行控制，事务的多次读取出现了**数据不一致**的问题（数据值）
3. **幻读**（数据量不一样）：指的是**范围操作**中，多次范围操作的**数据量**不一致，好像出现了幻觉，多读取或者少读取了一些数据（数据量）

#### 事务的隔离级别

|                           隔离级别                           |                             说明                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|            **`ISOLATION_DEFAULT`** <br />（默认）            | 后端使用什么数据库，就采用什么隔离级别，MySQL 默认采用的 `REPEATABLE_READ` 隔离级别， Oracle 默认采用的 `READ_COMMITTED` 隔离级别 |
|      **`ISOLATION_READ_UNCOMMITTED`**<br />（读未提交）      |   允许读取未提交的数据会出现脏读，幻读，不可重复读三种问题   |
| **`ISOLATION_READ_COMMITTED`** <br />（读已提交`ReadView`）  | 只允许读取已提交的数据，但是对于这一行数据没有进行并发控制，不会出现脏读，但是幻读和不可重复读还是会出现 |
| **`ISOLATION_REPEATABLE_READ`** <br />（可重复读`ReadView`） | 允许重复读，给当前行数据增加了并发控制，使得多次读取的数据是一致的，但是对于范围操作并没有进行并发控制，所以会出现记录数的变化，幻读还是会出现 |
|        **`ISOLATION_SERIALIZABLE`** <br />（序列化）         | **加读写锁**，事务之间操作数据的顺序是序列化的，但是这种隔离级别大大降低了数据库的性能 |

> 默认情况下，mysql采用可重复读来避免脏读和不可重复读，幻读**很大程度上被避免**

#### ~~如何解决幻读~~

1. ~~针对快照读：通过MVCC的方式，在事务读取数据的过程中如果插入了一条数据，那么此时是读取不到刚刚新增的数据的~~
2. ~~针对当前读：当事务读取数据的过程中插入了一条数据会失败，从而避免幻读~~

#### ReadView的作用（涉及到MVCC）

可以理解为一个快照，从而使得读已提交和可重复读这两种隔离级别可以正常运行，ReadView有四个字段：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom:50%;" />

所以一旦有了ReadView之后，一个记录涉及到的事务id就可以被分为三种：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png" alt="img" style="zoom:50%;" />

当一个事务去操作记录时，有三种情况：

1. 如果记录中已提交事务的id小于当前事务的id，那么意味着针对当前版本的记录来说，当前事务已提交，可以直接访问
2. 如果在没有开始的事务中，那么意味着当前版本的记录在当前事务创建后产生，不可访问
3. 如果在已启动但未提交中，那么意味着当前版本的记录来说，当前事务没提交，不能访问

#### 可重复读的工作原理

> 始终使用一个ReadView，不更新内部事务id的状态，每次读的都是同一个版本

在事务启动前开启一个事务并生成一个ReadView，之后全程使用这一个ReadView，这样就可以实现多次读取记录是一样的。按照ReadView所记录的事务id来判断当前记录是否可以读取，如果不可以读取就根据记录中的上一个版本指针找到上一版本，就这样根据ReadView判断当前记录是否可读，最终能找到可以读的记录

#### 读已提交的工作原理

> 每次创建新的ReadView，从而更新事务id的状态，每次读的都是新提交的

每次读取都会生成一个ReadView，ReadView更新之后，就可以读到最新提交的版本。具体还是按照里面记录的事务id判断当前版本的记录是否可以访问，不可以的话就按照上一版本链最终找到可以读取的版本

> 区别就是每次操作是否新建一个ReadView，新建了ReadView就会更新事务id的状态，是活跃还是已提交，从而实现可重复读和读已提交
>
> **可重复读**从头到尾都只有一个ReadView，从而每次读取到的都是事务开启时能够读取到的版本
>
> **读已提交**每次更新ReadView，从而内部的事务id更新，导致每次读取到的都是最新提交的版本
