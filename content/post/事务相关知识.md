---
title: "事务相关知识"
description: "事务相关知识"
keywords: "事务相关知识"

date: 2023-12-11T13:41:34+08:00
lastmod: 2023-12-11T13:41:34+08:00

categories:
  - 面试
tags:
  - 事务

# 原文作者
# Post's origin author name
author: zzzi
# 开启数学公式渲染，可选值： mathjax, katex
# Support Math Formulas render, options: mathjax, katex
math: mathjax
# 原文链接
# Post's origin link URL
#link:
# 图片链接，用在open graph和twitter卡片上
# Image source link that will use in open graph and twitter card
#imgs:
# 在首页展开内容
# Expand content on the home page
#expand: true
# 外部链接地址，访问时直接跳转
# It's means that will redirecting to external links
#extlink:
# 在当前页面关闭评论功能
# Disabled comment plugins in this post
#comment:
#  enable: false
# 关闭文章目录功能
# Disable table of content
#toc: false
# 绝对访问路径
# Absolute link for visit
#url: "面试笔记.html"
# 开启文章置顶，数字越小越靠前
# Sticky post set-top in home page and the smaller nubmer will more forward.
#weight: 1

# 开启各种图渲染，如流程图、时序图、类图等
# Enable chart render, such as: flow, sequence, classes etc
#mermaid: true
---

> 🤑 事务相关知识

本文中记录了spring中事务的相关知识点，可能总结的不够全面，后去如果遇到新的知识点会对文章进行补充，主要围绕事务的实现来展开讲解事务中的知识点

<!--more-->

## 事务

> 事务是逻辑上的一组操作，这些操作要么都执行，要么都不执行

实现事务需要基于数据库的回滚日志，事务在运行的过程中会记录日志，一旦出现异常回滚就会按照日志的操作恢复数据，有两种类型的事务：

1. 编程式事务：需要自己手动编程控制事务的提交或者回滚
2. 声明式事务：直接使用注解变成，由框架负责事务的控制，spring中提供一个待实现的接口，各个数据库的厂商自己实现自己的事务控制器

事务实现的原理就是使用了AOP，一旦使用了事务，那么就会给当前类创建一个代理对象，在方法执行前开启事务，如果正常结束就提交事务，没有正常结束就会回滚，期间需要注意事务管理器决定当前事务的传播行为，之后从数据库连接池中获取一个数据库的连接，执行完SQL之后，决定事务是否提交或者回滚，最终将数据库的连接归还给数据库连接池

### 事务的特性（ACID）

1. 原子性：事务就是最小的执行单位，要么全部完成，要么全部不完成
2. 一致性：事务执行前后，数据保持一致，例如转账的总金额保持一致，出多少入多少
3. 隔离性：事务之间的执行是隔离的
4. 持久性：事务的操作被提交之后，影响是永久的

![AID->C](https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202312111423205.png)

### 事务的传播行为

> 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播

|            传播行为            |                             说明                             |
| :----------------------------: | :----------------------------------------------------------: |
|   **`PROPAGATION_REQUIRED`**   | 当前不存在事务，那么就新建一个事务，否则就加入当前的事务，这是默认使用的事务传播行为。如果方法 A（PROPAGATION_REQUIRED）调用了方法 B（PROPAGATION_REQUIRED），方法 B 将加入到方法 A 的事务中。如果方法 B 抛出异常，则方法 A 和 B 都会回滚。 |
| **`PROPAGATION_REQUIRES_NEW`** | 当前存在事务，会将当前事务**挂起**，然后执行自己的事务，相当于事务之间互不影响，挂起当前事务的操作是与**`PROPAGATION_NESTED`**最核心的区别 |
|    **`PROPAGATION_NESTED`**    | 当前存在事务，会在当前事务内部重新创建一个事务，二者相互不影响，并且当前事务并不会被挂起，如果当前不存在事务，那么**`PROPAGATION_NESTED`**与**`PROPAGATION_REQUIRED`**等价 |
|    `PROPAGATION_MANDATORY`     |         当前存在事务加入当前事务，不存在事务抛出异常         |
|      `PROPAGATION_NEVER`       |            以非实物方式运行，当前存在事务抛出异常            |

> 事务的传播行为指的是事务在执行过程中遇到其他类型的事务怎么处理，分为加入，新建，嵌套，报错等处理方式

### 事务的隔离级别

在介绍事务的隔离级别之前，会介绍并发事物中可能遇到的一些数据一致性问题：

1. **脏读**：指的是一个事务读取了另外一个事务未提交的数据。一个事务由于一些情况修改了数据但是最终并没有提交，而这个没有被提交的事务被其他事务读取到就会出现脏读
2. **不可重复读**：指的是对于同一行数据来说，由于没有针对事务的并发操作进行控制，事务的多次读取出现了数据不一致的问题
3. **幻读**：指的是范围操作中，多次范围操作的数据量不一致，好像出现了幻觉，多读取或者少读取了一些数据

|                      隔离级别                      |                             说明                             |
| :------------------------------------------------: | :----------------------------------------------------------: |
|       **`ISOLATION_DEFAULT`** <br />（默认）       | 后端使用什么数据库，就采用什么隔离级别，MySQL 默认采用的 `REPEATABLE_READ` 隔离级别， Oracle 默认采用的 `READ_COMMITTED` 隔离级别 |
| **`ISOLATION_READ_UNCOMMITTED`**<br />（读未提交） |   允许读取未提交的数据会出现脏读，幻读，不可重复读三种问题   |
| **`ISOLATION_READ_COMMITTED`** <br />（读已提交）  | 只允许读取已提交的数据，但是对于这一行数据没有进行并发控制，不会出现脏读，但是幻读和不可重复读还是会出现 |
| **`ISOLATION_REPEATABLE_READ`** <br />（可重复读） | 允许重复读，给当前行数据增加了并发控制，使得多次读取的数据是一致的，但是对于范围操作并没有进行并发控制，所以会出现记录数的变化，幻读还是会出现 |
|   **`ISOLATION_SERIALIZABLE`** <br />（序列化）    | 这种事务的隔离级别最高，事务之间操作数据的顺序是序列化的，但是这种隔离级别大大降低了数据库的性能 |

### @Transactional的常用参数

|   属性名    |                             说明                             |
| :---------: | :----------------------------------------------------------: |
| propagation |   事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过    |
|  isolation  |   事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过   |
|   timeout   | 事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。 |
|  readOnly   | 指定事务是否为只读事务，默认值为 false。只读事务会进行再次优化 |
| rollbackFor | 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。 |

### 事务的失效

1. `@Transactional`加在了私有方法上

2. 事务隔离级别设计不到位，例如设计了读已提交会出现不可重复读和幻读问题

3. 使用了事务的方法被final修饰，导致无法AOP，也就会导致事务失效

4. 方法内部自调用：

   > 由于事务内部自调用，调用的是被代理对象中没有AOP被增强的**原始**方法，也就是直接使用this调用，而这个this是一个**普通对象**，没有被AOP增强，自调用时调用的不是被增强的方法，所以事务会失效，解决办法有如下三种：
   >
   > 1. 将内部调用的方法分离出来形成一个新的类
   > 2. 或者直接**自身注入自身**，这样注入进来的对象就是被AOP增强的对象，调用它内部的方法事务就不会失效
   > 3. 最后一种方式就是使用`AopContext`获取到当前的代理对象，从而调用其被增强的方法
   >
   > 但是三种方法中可读性最好的还是第二种方法

5. 使用了`@Transactional`的类没有被spring管理，从而导致不会产生AOP，也就不会有事务

6. 数据库底层不支持事务，利用mysql的myisam就不支持事务

7. 设置了错误的传播属性导致不回滚

8. `rollbackFor`设置的异常属性有问题，导致不回滚

9. 异常被try-catch处理，不回滚

10. 。。。

## 其他

1. 当事务出现异常需要回滚时，默认只有出现`RuntimeException`时才会回滚，此时如果需要改变回滚的级别，就需要使用`@Transactional(rollbackFor = xxxException.class)`

2. `@Transactional`在方法上使用时，只能使用在public修饰的方法中
